# 시간 복잡도

코딩테스트에서 시간 복잡도를 감안해서 풀어야 하는 문제들이 많다. 그래서 ‘쉬운 코드’님의 유투브 영상을 보며 혼자 정리해보았다.

**시간 복잡도 정의**

- 시간 복잡도는 함수의 수행 시간인데, 컴퓨터 성능마다 수행 시간이 다르게 나올 수 있으니 알고리즘 수행에 필요한 스텝 수라고 가정한다.
- 그리고 코드의 각 라인은 수행하기 위해 필요한 스텝 수는 상수라고 가정하자.

```java
//inputs를 N이라고 가정
int[] multiply(int[] inputs, int multiplier){
	//c1
	int[] nums = new int[inputs.length];
	//c2
	for(int i=0; i<inputs.length; i++){
	//c3
		nums[i] = inputs[i] * multiplier;
	}
	//c4
	return nums;
}
```

각 코드별로 스텝 수를 구해보면, c1 ⇒ 1, c2 ⇒ N+1, c3 ⇒ N, c4 ⇒ 1이다. 이 결과로 식을 세워보자

T(N) = c1 + c2*(N+1) + c3*N + 1

⇒ (c2+c3)*N + c1 + c2 + 1

⇒ a*N + b (보기 편하게 a와 b로 치환)

위의 도출된 식에서 N→**∞일 때를 생각해보자**

⇒ N이 커질수록 덜 중요한 것은 제거

⇒ 최고차항만 의미가 있다. → a*N만 의미가 있고 b는 의미가 없음(제거)

⇒ 최고차항의 계수는 의미 없다 → a*N에서 a는 의미가 없음

### ☞ 그럼 결국 남는 식을 표현하면 θ(N)이렇게 표시하게 된다. 이렇게 표시하는 것이 바로 점근적 표기법이다. 그리고 위의 분석 방법이 점근적 분석 방법이다.

## 점근적 분석 방법을 통한 lower bound, upper bound, tight bound 표기

```java
//inputs를 N이라고 가정
boolean exists(int[] inputs, int target){
	for(int i=0; i<inputs.length; i++){
			if(inputs[i] == target){
				return true;
			}
	}
	return false;
}
```

위의 코드에서 시간 복잡도를 구할 때, 함수의 파라미터 데이터에 따라 실행 시간이 조금씩 다르다.(원하는 데이터가 처음에 나오면 바로 끝나고, 맨 마지막에 나오면 N만큼 시간이 걸림)

이때 최소 시간(best), 최대 시간(worst)를 표로 정리해보면,

| case  | when                           | times                                                        |
| ----- | ------------------------------ | ------------------------------------------------------------ |
| best  | 0번째에 존재                   | 1(lower)→’함수 실행 시간은 아무리 빨라도 상수 시간 이상이다’라고 정의 가능→최소 시간(lower bounds)는 𝝮로 표시 가능→ 𝝮(1) |
| worst | 마지막에 존재 or 존재하지 않음 | N(upper)→’함수 실행 시간은 아무리 오래 걸려도 N에 비례하는 정도 이하’라고 정의 가능→ 최대 시간(upper bounds)는 O로 표시 가능 → O(N) |

위의 case를 각각 lower bounds, upper bounds로 표시해보면

|      | best | worst | avg  |
| ---- | ---- | ----- | ---- |
| 𝝮    | 𝝮(1) | 𝝮(N)  |      |
| O    | O(1) | O(N)  | O(N) |
| θ    | θ(1) | θ(N)  |      |

- 세타(**θ)는 lower와 upper가 같을 때 표기할 수 있고, lower, upper가 같은 경우는 매우 타이트한 경우이므로 tight bounds라고도 불린다.**
- avg는 N/2까지 실행해보고 판단하는 경우인데, 2/1*N에서 계수는 의미 없다고 했으므로 그냥 N이 되어 O(N)으로 표기한다.

**정리**

| 점근적 표기법 | case 분류              |
| ------------- | ---------------------- |
| lower bounds  | best(최단 시간 실행)   |
| upper bounds  | worst(최장 시간 실행)  |
| tight bounds  | average(일반적인 실행) |

### 위의 시간 복잡도 정의 방법을 토대로 이진 탐색 시간 복잡도를 구해보자

- 이진 탐색은 실행해야 하는 길이의 반을 나누어 조건을 비교하며 왼쪽, 오른쪽으로 탐색해보는 알고리즘이다.
- 그럼 이진 탐색은 매번 실행할 때 마다 1/2씩 사이즈가 줄어든다. 이때, 몇 번만에 사이즈는 1이 되는가가 중요하다⇒ input size를 N이라고 가정했을 때 N*(1/2)**k = 1

⇒ N/2**k = 1 → N = 2**k → log2N = log2의 2k ⇒ k=log2N

도출된 식의 K를 점근적 표기법으로 계산해보면 O(logN)이 나온다.

## 시간 복잡도의 속도 비교

***O(1)** < **O(logN)** < **O(N)** < **O(N*logN)** < **O(N^2)** < **O(2^N)** < **O(N!)***

**!!! 참고로 n\*longn의 시간 복잡도를 가지는 알고리즘은 collections.sort()이다.**