# 운영체제 개요

### 운영체제(Operating System)란

컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.

운영체제가 있기 때문에 일반 사용자들도 하드웨어를 잘 모르지만 컴퓨터를 다룰 수 있다.

### 운영체제 기능

컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공한다.

-운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는것 같은 환상(illusion)을 제공한다. 즉, 윈도우OS를 사용하는 사용자는 윈도우가 하드웨어의 복잡한 부분을 직접 다루기 때문에 쇼핑을 하면서 노래도 듣고 할 수 있는 것이다.

## 운영체제의 가장 중요한 목적!! ⇒ 컴퓨터 시스템의 자원을 효율적으로 관리

-실행중인 프로그램들에게 짧은 시간씩 CPU를 번갈아 할당시킨다. 실행중인 프로그램들에 메모리 공간(DRAM)을 적절히 분배한다.

-메모리는 CPU의 작업 공간!! 그래서 CPU에서 프로그램이 실행되려면 메모리에 프로그램이 반드시 올려져있어야 한다. 이 모습을 생각해보면 메모리에 올려진 내용을 CPU가 들고가서 처리한다고 보면 될 것 같다.

-아까전에 쇼핑을 하면서 노래도 들을 수 있다고 예를 들었다. 이 모습을 OS의 입장에서 바라보면, 쇼핑 프로그램을 CPU에 할당시켜 처리를 한 후, 그 다음 노래 프로그램을 CPU에 할당시켜 처리한다. 그럼 프로그램 입장에서는 마치 자신이 CPU를 독점하고 있다고 여긴다.

## 컴퓨터 시스템의 구조

![os.png](https://github.com/nahyeonung/KCC_Java/blob/main/images/os.png)

- 메모리 맨 밑에 OS가 있는 이유: 컴퓨터가 작동하자 마자 실행되는 것이고, 컴퓨터가 종료될 때까지 실행되는 것이기 때문
- I/O controlller: CPU는 I/O 디바이스와 직접 교류할 수 없어서 I/O controller를 통해 교류한다.
- 메모리에 올라온 프로그램 중에 어떤 프로그램에게 CPU 사용권을 줄 것인지 정하는 것⇒ CPU스케줄링
- 메모리에 올라온 프로그램 중에 하드디스크에 접근해서 내용을 받아와야하는 일이 있을 수 있다. 그럼 CPU는 하드디스크에 원하는 내용을 요청하고 내용을 받게 되는데, 이때 하드 디스크의 처리 속도는 CPU에 비하면 매우 느리다. 그래서 빠른 CPU와 느린 I/O장치간 속도차를 극복하는 방법이 있는데 그것이 바로 인터럽트와 캐싱이다.

### 하드디스크에서 실행파일을 실행 했을 때 프로세스가 메모리에 담기는 순서

1. 디스크에서 실행 파일이 실행된다
2. 메모리에 들어가기 전, 가상 메모리에 프로세스가 담긴다.
3. 가상 메모리에 담긴 프로세스 중 필요한 부분들은 메모리에 들어가고 메모리에 자리가 없으면 다른 디스크에 보관이 된다.(스왑영역 디스크에 보관됨)

*이때! 디스크의 실행 요청으로 메모리가 가득 찼을 때, 다시 메모리에 실행 요청이 들어오면 메모리는 어떤 프로세스를 지우고 새로운 실행 프로세스를 넣을까?*

⇒ LRU or LFU 방식으로 메로리를 처리함!

### 디스크 스케줄링

우선, 디스크는 원판이 회전하는 매체라는 것을 기억하자! 디스크는 각 트랙으로 이루어져 있고 헤더라는 것이 움직이며 요청에 맞는 트랙에 도달하여 요청을 처리하는 방식이다.

디스크에 파일을 저장하거나 읽어달라는 등의 요청이 들어오면 디스크 큐에 큐 형식으로 요청이 순서대로 쌓인다.

헤더가 큐에 쌓인 요청에 알맞은 트랙에 도달하여 요청을 처리하기 때문에, 헤더가 움직이는 시간(seek-time)이 최소화 되는 것이 가장 빠르게 요청을 처리할 수 있는 방법이라고 할 수 있다.

큐에 쌓인 요청 중 헤더의 위치에 가장 가까운 요청을 순서대로 하는 방법(SSTP)이 좋아 보이지만 starvation이 생길 수 있기 때문에 가장 괜찮은 방법으로는 scan 스케줄링을 사용한다.

SSD가 빠른 이유(추가적 내용)

하드 디스크는 마크네틱을 사용하지만 SSD는 플래시 메모리(반도체 장치)를 사용하기 때문에 속도 측면에서 빠름(플래시 메모리가 충격에도 강함)