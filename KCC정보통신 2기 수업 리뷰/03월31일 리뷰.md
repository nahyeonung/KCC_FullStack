# 3일차 리뷰



### 실수 타입이 컴퓨터에 저장되는 모습(float를 예시)

*실수에서 소수점 밑의 숫자를 2진수로 바꾸는 방법 ⇒ 2^-1 2^-2….으로 표현한 후 소수점 위의 자리 구하는 방법과 같은 방법으로 구함.*

float는 부호를 1비트, 지수를 8비트, 가수를 23비트로 저장함.

ex) -102.625(10) ⇒ -1100110.101(2) ⇒ -1.100110101 x 2^6 ⇒ 가수(소수점 뒤): 100110101, 지수: 6

1. 10진수로 표현된 실수를 2진수로 치환
2. 소수점을 한 자리 빼고 바로 다음에 올 수 있도록 만들어 주고 이동한 만큼 2의 제곱승을 곱해줌(정규화)
3. 부호비트에는 양수면 0, 음수면 1로 채움(컴퓨터가 실수는 정수와 다르게 부호를 보수로 변환하거나 하지 않고 그냥 -가 들어오면 1, 아니면 0으로 채우는 방식임)
4. 지수는 음수로 표현될 수 있으니까(ex 2^-1) 비트에 넣을 때 표현 방법을 다르게 해줘야 함. 이때 bias라는 값을 넣어서 계산을 하기로 했음 bias는 2^비트 -1의 값 즉, float에서는 지수에 8비트를 쓴다고 했으니까 2^8 -1 = 127의 값을 bias로 둠. 비트로 표현하면 01111111을 채워 넣은 상태를 default상태라고 보면 됨. 여기서 우리는 6이라는 지수를 구했으니까 127 + 6 = 133 즉, 지수 비트에 10000101이라는 값이 들어감.(음수면 127에서 빼주면 되겠지? 해보진 않음 ㅎㅎ)
5. 맨위의 소수점 한 자리를 빼고 가수 저장 비트 앞 부분부터 차례대로 넣은 후 뒤에는 0으로 채움

⇒ 파랑: 부호, 주황: 지수, 검정: 가수로 저장된 모습

| 1    | 1    | 0    | 0    | 0    | 0    | 1    | 0    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |

| 1    | 0    | 0    | 1    | 1    | 0    | 1    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

실수의 소수점부분이 딱 떨어지지 않을 수 있다 0.3같은 경우

## Scanner nextInt(), nextLine()의 사용(feat.개행문자)

nextInt()를 사용한 이후 nextLine()을 사용하면 nextLine()을 입력하지도 않았는데 실행문이 종료되는 오류가 발생한다.

```java
Scanner scan = new Scanner(System.in);
int a = scan.nextInt();
String b = scan.nextLine(); // 이러면 nextInt값만 받고 실행문 종료
```

에러의 이유에 대해서 살펴보고 해결법을 정리해보자.

우선, 키보드로 타이핑 되는 값들이 RAM에 저장이 되고 그 저장된 값을 CPU가 쓰는 모습을 생각해보자. 그리고 개행문자(enter 등)은 RAM에 $라는 값으로 저장된다고 가정한다.

위의 코드를 보면 nextInt()로 정수를 먼저 받는다.(사실 String을 받아서 정수로 처리하는 거긴 하지만..) 15를 받고 nextInt()문을 종료 하기 위해 enter를 치면 15$라는 값이 RAM에 들어간다. 그런데 여기서 nextInt()는 enter인 $값 앞의 정수만 들고가고 $는 RAM에 남겨둔다. 남겨진 $를 보고 nextLine()은 개행문자니까 종료를 하라는 뜻으로 간주하고 바로 입력을 종료 시킨다. 그래서 실행문이 종료 되는 것이다. 이에 해결 방안은 nextLine()으로 원하는 값을 입력 받기 전에 한번 더 nextLine()을 해줌으로써 RAM에 남아있던 $(enter)를 CPU가 들고 가버리도록 하는 방법이다.

```java
Scanner scan = new Scanner(System.in);
int a = scan.nextInt();
scan.nextLine();
String b = scan.nextLine();
```

## 여기서 nextInt()를 더 살펴보자면..

```java
Scanner scan = new Scanner(System.in);
System.out.println("두 정수를 입력하세요");
int a = scan.nextInt();
int b = scan.nextInt();
System.out.println(a + b);
```

위의 코드를 사용하면 20 spacebar 30을 입력하고 enter를 눌려도 되고 20 enter 30 enter를 해도 값이 제대로 들어간다. 이유는 nextInt()는 구분자가 있어서 정수를 기준으로 주변 공백, enter에 반응하여 값을 잘 구분해서 넣어주기 때문에 값이 잘 들어간다.(위의 예를 더해 $(enter)라는 값이 RAM에 남아 있어도 정수를 기준으로 행위를 하기 때문에 실행문이 종료되거나 하지 않는다.);

## Scanner.next()

- nextLine()처럼 String타입을 읽어들이지만 next()는 nextInt()가 버리고 간 spacebar(공백)을 주워담지 않는다.  “    abc”를 입력해도 abc만 String변수에 저장함

## 증감 연산자(++, - -)

증감 연산자가 변수 앞에 붙으면 해당 라인 실행할 때 값에 적용된다.

```java
int i = 10;
int result = ++i + 10;
System.out.println(i);  //11
System.out.println(result); //21
```

증감 연산자가 변수 뒤에 붙으면 해당 라인이 종료한 후에 값에 적용된다.

### 실수 타입이 컴퓨터에 저장되는 모습(float를 예시)

*실수에서 소수점 밑의 숫자를 2진수로 바꾸는 방법 ⇒ 2^-1 2^-2….으로 표현한 후 소수점 위의 자리 구하는 방법과 같은 방법으로 구함.*

float는 부호를 1비트, 지수를 8비트, 가수를 23비트로 저장함.

ex) -102.625(10) ⇒ -1100110.101(2) ⇒ -1.100110101 x 2^6 ⇒ 가수(소수점 뒤): 100110101, 지수: 6

1. 10진수로 표현된 실수를 2진수로 치환
2. 소수점을 한 자리 빼고 바로 다음에 올 수 있도록 만들어 주고 이동한 만큼 2의 제곱승을 곱해줌(정규화)
3. 부호비트에는 양수면 0, 음수면 1로 채움(컴퓨터가 실수는 정수와 다르게 부호를 보수로 변환하거나 하지 않고 그냥 -가 들어오면 1, 아니면 0으로 채우는 방식임)
4. 지수는 음수로 표현될 수 있으니까(ex 2^-1) 비트에 넣을 때 표현 방법을 다르게 해줘야 함. 이때 bias라는 값을 넣어서 계산을 하기로 했음 bias는 2^비트 -1의 값 즉, float에서는 지수에 8비트를 쓴다고 했으니까 2^8 -1 = 127의 값을 bias로 둠. 비트로 표현하면 01111111을 채워 넣은 상태를 default상태라고 보면 됨. 여기서 우리는 6이라는 지수를 구했으니까 127 + 6 = 133 즉, 지수 비트에 10000101이라는 값이 들어감.(음수면 127에서 빼주면 되겠지? 해보진 않음 ㅎㅎ)
5. 맨위의 소수점 한 자리를 빼고 가수 저장 비트 앞 부분부터 차례대로 넣은 후 뒤에는 0으로 채움

⇒ 파랑: 부호, 주황: 지수, 검정: 가수로 저장된 모습

| 1    | 1    | 0    | 0    | 0    | 0    | 1    | 0    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |

| 1    | 0    | 0    | 1    | 1    | 0    | 1    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

실수의 소수점부분이 딱 떨어지지 않을 수 있다 0.3같은 경우

## Scanner nextInt(), nextLine()의 사용(feat.개행문자)

nextInt()를 사용한 이후 nextLine()을 사용하면 nextLine()을 입력하지도 않았는데 실행문이 종료되는 오류가 발생한다.

```java
Scanner scan = new Scanner(System.in);
int a = scan.nextInt();
String b = scan.nextLine(); // 이러면 nextInt값만 받고 실행문 종료
```

에러의 이유에 대해서 살펴보고 해결법을 정리해보자.

우선, 키보드로 타이핑 되는 값들이 RAM에 저장이 되고 그 저장된 값을 CPU가 쓰는 모습을 생각해보자. 그리고 개행문자(enter 등)은 RAM에 $라는 값으로 저장된다고 가정한다.

위의 코드를 보면 nextInt()로 정수를 먼저 받는다.(사실 String을 받아서 정수로 처리하는 거긴 하지만..) 15를 받고 nextInt()문을 종료 하기 위해 enter를 치면 15$라는 값이 RAM에 들어간다. 그런데 여기서 nextInt()는 enter인 $값 앞의 정수만 들고가고 $는 RAM에 남겨둔다. 남겨진 $를 보고 nextLine()은 개행문자니까 종료를 하라는 뜻으로 간주하고 바로 입력을 종료 시킨다. 그래서 실행문이 종료 되는 것이다. 이에 해결 방안은 nextLine()으로 원하는 값을 입력 받기 전에 한번 더 nextLine()을 해줌으로써 RAM에 남아있던 $(enter)를 CPU가 들고 가버리도록 하는 방법이다.

```java
Scanner scan = new Scanner(System.in);
int a = scan.nextInt();
scan.nextLine();
String b = scan.nextLine();
```

## 여기서 nextInt()를 더 살펴보자면..

```java
Scanner scan = new Scanner(System.in);
System.out.println("두 정수를 입력하세요");
int a = scan.nextInt();
int b = scan.nextInt();
System.out.println(a + b);
```

위의 코드를 사용하면 20 spacebar 30을 입력하고 enter를 눌려도 되고 20 enter 30 enter를 해도 값이 제대로 들어간다. 이유는 nextInt()는 구분자가 있어서 정수를 기준으로 주변 공백, enter에 반응하여 값을 잘 구분해서 넣어주기 때문에 값이 잘 들어간다.(위의 예를 더해 $(enter)라는 값이 RAM에 남아 있어도 정수를 기준으로 행위를 하기 때문에 실행문이 종료되거나 하지 않는다.);

## Scanner.next()

- nextLine()처럼 String타입을 읽어들이지만 next()는 nextInt()가 버리고 간 spacebar(공백)을 주워담지 않는다.  “    abc”를 입력해도 abc만 String변수에 저장함

## 증감 연산자(++, - -)

증감 연산자가 변수 앞에 붙으면 해당 라인 실행할 때 값에 적용된다.

```java
int i = 10;
int result = ++i + 10;
System.out.println(i);  //11
System.out.println(result); //21
```

증감 연산자가 변수 뒤에 붙으면 해당 라인이 종료한 후에 값에 적용된다.

```java
int j = 10;
int result2 = j++ + 10;
System.out.println(j); //11
System.out.println(result2); //20
```