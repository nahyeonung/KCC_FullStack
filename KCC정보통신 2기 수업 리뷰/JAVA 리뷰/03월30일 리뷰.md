# 2일차 리뷰

## Build Automatically

eclipse에서 project → build automatically는 코드를 변환하고 저장 시 자동으로 빌드해주는 도구이다. 즉, ctrl + s를 누르면 바로 빌드를 시켜주는 것 같다. 그렇기 때문에 대규모 프로젝트의 코드를 수정하는 경우에는 빌드가 느리기 때문에 build automatically를 끄고 코드를 수정하는 것이 좋다.

## String과 Char

**Char**

- char는 Charactor의 약자
- 단 하나의 문자만 저장
- 2byte(사실 상 정수)
- char 타입의 리터럴은 작은 따옴표(’ ‘)로 감싸서 표현
- 컴퓨터 내부에 저장될 땐 정수로 치환(아스키 코드)

*여기서 리터럴이란 프로그래머가 직접 입력한 값을 가리킨다.*

실제로 컴퓨터는 문자를 구별할 수 없다. 즉, 컴퓨터에는 문자가 저장되지 않고 모든 것이 숫자로 저장된다. 이 때, 사람이 말하는 문자 → 컴퓨터가 이해하는 숫자의 표현 규약을 아스키코드 규칙에 맞게 저장한 것이다(ex. A ⇒ 65로 저장)

```jsx
char c = 'A'; 
//컴퓨터가 c변수를 65라는 값으로 저장하고 println을 해주면 65를 'A'로
//치환해서 띄워줌'
char c2 = 65;
//컴퓨터가 c2변수를 65라는 값으로 저장하고 println을 해주면 65를 'A'로
//치환해서 띄워줌

System.out.println(c + c2)
//c와 c2는 아스키코드값인 65로 저장되었고, 더하기 연산자를 사용하면서
//int로 변형이 발생한다!!! => 즉, 위의 값은 65 + 65가 되어 130이 출력된다.
```

**String**

- 자바에서 제공하는 문자열 클래스
- 문자(char)들의 배열을 의미
- String 클래스 타입은 큰 따옴표(” “)로 감싸서 표현
- 미리 구현된 다양한 함수들을 통해서 다룰 수 있음

String은 자바에서 구현된 클래스임으로 실제로 선언할 때 변수에 값을 저장하는 방식이 아닌 하나의 객체를 생성하고, 해당 객체에 문자들을 연결시킬 수 있다.

```jsx
//인스턴스 생성
String 변수 = new String("문자열");

//변수에 직접 대입도 가능
String 변수 = "문자열";
```

String은 한 번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수는 없다. 이러한 객체를 불변 객체라고 한다. 여기서 불변객체는 재할당은 가능하지만, 한번 할당하면 내부 데이터를 변경할 수 없는 객체이다. String은 str = “a”, str = “b”이렇게 사용하기 때문에 값이 변경한다고 생각하지만 이것은 값이 변경된 것이 아니라 str가 “a” 객체를 참조하다가 “b”라는 객체를 새로 만들고 그것을 참조하는 것이다.(즉, a 객체는 변하지 않고 살아있음)

```jsx
String이 불변객체라는 것을 증명하는 코드
public class Example {
	public static void main(String[] args) {
		String a = "첫번째";
		int address = System.identityHashCode(a);
		System.out.println(address); //1554547125라는 주소를 가리킴
		a = "두번째";
		address = System.identityHashCode(a);
		System.out.println(address); //값이 변하니까 617901222라는 주소를 가리킴
		String b = "첫번째";
		address = System.identityHashCode(b);
		System.out.println(address); 
		//b에 첫번째라는 문자열을 담으니까 처음 a와 같이 1554547125라는 주소 출력
	}
}
```

## 자료구조

6비트로 예시를 들어보면 저장할 수 있는 양수가 2^6-1만큼 저장이 가능하다. 하지만 우리는 음수도 반 떼어서 표시해줘야 하기 때문에 2 X 2^5으로 나눠서 양수(0포함) 2^5-1만큼 표현, 음수 -(2^5)만큼 표현 해줄 수 있다.

양수는 000000를 시작으로 1씩 증가한 모습을 표현하면 되지만 음수가 문제다. 음수를 표현할 방법을 찾다가 앞의 최상위 비트를 부호비트로 사용하고 나머지 비트를 숫자 표현하는 방법으로 사용하는 생각을 해본다.(부호화 절대값) 이렇게 했을 때 표현은 가능하지만 연산 시 오류가 생긴다. 예를들어 000001(2)는 1이고 100000(2)는 -1이 되는데, 이 둘을 연산하면 10진수로는 0이라는 값이 나와야 하지만 2진수로 100001라는 엉뚱한 값이 나온다. 그래서 이 방법은 사용할 수 없다.

그래서 사용한 방법이 보수, +1을 해주는 방법이다. 이 방법대로 하면 1111111(2)이 -1이되고 1씩 줄어들면서 값이 -1씩 증가한다. 이 모습을 표현하면

```jsx
0000000 => 0
0000001 => 1
  *
  *
  *
0111111 => 127
1111111 => -1
1111110 => -2
  *
  *
1000000 => -128 
```

이렇게 컴퓨터에 숫자 표현을 해준 것이다.

이 내용을 토대로 21 - 24를 2진수로 계산을 해보면

21 ⇒ 10101(2) ⇒ 앞에 부호 비트를 선언해줘서 010101(2)로 만듬(굳이 안만들어도 계산은 지장없음 왜냐하면 부호 비트는 숫자에 관여하지 않기 때문)

-24 ⇒ 24를 먼저 구함 ⇒ 11000(2) ⇒ 앞에 부호 비트를 선언해서 011000(2)로 만듬 ⇒ 위에서 설명했든 컴퓨터는 음수를 보수 , +1을 해주는 것으로 정했으니 보수를 해주면 100111 ⇒ +1을 하면 101000(2) 이것이 -24의 2진수 표현

010101(2) + 101000(2) = 111101(2)

111101(2)는 음수 표현이어서 위의 모습대로 -1씩 해주면 금방 -3이라는 것이 나오지만 이렇게 하지 말고 음수를 부호를 바꿔서 양수로 계산한 후 부호를 -붙여주면 결과는 같으니 이 방법으로 하자

부호 바꾸면(보수, +1) ⇒ 000011(2) ⇒ 3 ⇒ -부호를 붙여주면 -3이라는 정답이 나온다.

## 강제 타입 연산 시 오버플로 된 엉뚱해진 값(byte예시)

byte는 양수로 127이라는 숫자까지 저장이 가능하다. 그 위로 저장을 하게 되면 에러가 난다. 하지만 강제로 넣는 방법이 있는데 강제 타입 변환 방법이다. 강제 타입 변환을 사용해버리면 엉뚱한 값이 저장된다.

```jsx
//강제 타입 변환
byte 6 = (byte)129; //-127이 출력된다.
```

-127이 출력 되는 이유를 살펴보면, 2진수로 표현된 129는 10000001이다. 이 값은 int형같은 타입으로 선언이 되었다면 앞에 부호를 알려주는 최상위 비트가 있어서 대충 000010000001이런 모양일 것이다. 하지만 byte는 8비트만 저장할 수 있으니 앞에 0이 다 날라가고 10000001만 남는다. 그래서 부호 비트인 최상위 비트를 1로 인식하고 음수니까 보수, +1을 해주면 01111111이 된다. 이건 127이고 우리는 음수를 뒤집은 거였으니 -127이 나오게 된다. 이런 형식으로 오버플로가 발생 시 값이 엉뚱하게 나오게 된다.